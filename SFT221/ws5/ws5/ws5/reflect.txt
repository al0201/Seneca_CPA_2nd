Workshop 5 - Reflection
Name : Ahram Lee
Email : alee239@myseneca.ca
Student ID : 133849232
Date: 2024-06-07


1. The most useful debugger tool I used was the breakpoint functionality combined with the watch window in Visual Studio. Setting breakpoints allowed me to pause the execution at critical points and examine the state of variables and program flow. The watch window provided real-time updates on variable values, helping me to quickly identify where the logic was failing or where unexpected values were occurring. This combination was more effective than print statements because it offered a non-intrusive and dynamic way to inspect the program without altering the code. Additionally, it allowed for a deeper dive into the programâ€™s state across multiple iterations, which print statements alone could not provide efficiently.

2. I did not use the memory window and the disassembly window in Visual Studio. The memory window, which allows viewing the raw memory content, was not necessary for this debugging session because the bugs were logical errors in the code rather than memory corruption issues. Similarly, the disassembly window, which shows the assembly code generated from the source code, was not used as the problem did not require inspecting the low-level assembly instructions. An example where I would use the memory window is in debugging pointer issues or memory leaks, while the disassembly window would be useful for performance optimization or debugging at the instruction level in low-level system programming.

3. Using the debugger alone is generally the fastest way to find bugs. The debugger provides powerful tools like breakpoints, watch windows, and call stacks, which allow for a comprehensive inspection of the program's state without modifying the code. Print statements can be useful for simple debugging tasks but often require multiple iterations to insert, run, and analyze the output, which can be time-consuming. Combining both can sometimes be beneficial, but it can also clutter the code and slow down the process. The debugger's ability to dynamically explore the code and its state makes it more efficient and effective for most debugging tasks.

4. To test the program, I initially used the supplied test data to identify obvious bugs and validate the fixes. Once those were addressed, I created additional test cases to cover edge cases and scenarios not included in the original data. These included strings with multiple consecutive spaces, strings without numbers, strings with special characters, and empty strings. I used a combination of manual test case creation and boundary value analysis to ensure thorough coverage. I am confident that I found and fixed all the major bugs, as the program now handles all test cases correctly and no additional issues were detected during further testing.
